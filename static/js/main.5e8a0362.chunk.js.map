{"version":3,"sources":["lockdown.js","../../captp-stream/index.js","NameComponent.js","App.js","index.js","duplex-socket.js"],"names":["mathPow","Math","pow","base","exp","lockdown","__allowUnsafeMonkeyPatching__","errorTaming","overrideTaming","consoleTaming","makeCapTpFromStream","streamId","bootstrap","dispatch","getBootstrap","abort","stream","Duplex","_read","noop","capTp","makeCapTP","obj","push","JSON","stringify","_write","enc","cb","parse","err","_writev","chunks","forEach","_final","E","captpStream","NameComponent","props","useState","name","setNameSync","draftName","setDraftName","updateLatestName","latestNamePromise","then","latestName","nextNamePromise","getLatestName","console","log","type","placeholder","onChange","event","target","value","onClick","setName","ret","catch","reason","error","nextNameUpdate","makeDuplexPair","require","pumpify","clientSide","serverSide","serverStream","harden","getName","a","Promise","res","setTimeout","newName","updateFunc","clientStream","App","undefined","setBootstrap","setError","body","className","ReactDOM","render","StrictMode","document","getElementById","assert","kCallback","Symbol","kOtherSide","DuplexSocket","opts","callback","this","chunk","_encoding","notStrictEqual","strictEqual","on","module","exports","objectMode"],"mappings":"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","file":"static/js/main.5e8a0362.chunk.js","sourcesContent":["import 'ses';\nimport '@agoric/eventual-send/shim.js';\n\nconst consoleTaming = '%NODE_ENV%' === 'production' ? 'safe' : 'unsafe';\n\nconst { pow: mathPow } = Math;\nMath.pow = (base, exp) =>\n  typeof base === 'bigint' && typeof exp === 'bigint'\n    ? base ** exp\n    : mathPow(base, exp);\n\nlockdown({\n  __allowUnsafeMonkeyPatching__: 'unsafe',\n  errorTaming: 'unsafe',\n  overrideTaming: 'severe',\n  consoleTaming: consoleTaming,\n});\n","import { makeCapTP, E } from '@agoric/captp';\nimport { Duplex } from 'stream';\n\nexport default function makeCapTpFromStream (streamId, bootstrap) {\n  let dispatch, getBootstrap, abort;\n\n  const stream = new Duplex();\n\n  stream._read = noop;\n\n  const send = (obj) => {\n    stream.push(JSON.stringify(obj));\n  };\n\n  const capTp = makeCapTP(streamId, send, bootstrap);\n  ({ dispatch, getBootstrap, abort } = capTp);\n\n  stream._write = (obj, enc, cb) => {\n    try {\n      dispatch(JSON.parse(obj));\n    } catch (err) {\n      return cb(err);\n    }\n    cb();\n  };\n\n  stream._writev = (chunks, cb) => {\n    try {\n      chunks.forEach((obj) => {\n        dispatch(JSON.parse(obj));\n      });\n    } catch (err) {\n      return cb(err);\n    }\n    cb();\n  }\n\n  stream._final = (cb) => {\n    abort();\n    cb();\n  }\n\n  return { getBootstrap, abort, E, captpStream: stream }\n};\n\nfunction noop () {}\n","import { useState } from 'react';\n\nexport default function NameComponent (props) {\n\n  const [ name, setNameSync ] = useState('Loading name...');\n  const [ draftName, setDraftName ] = useState(name);\n\n  const { E, bootstrap } = props;\n  E(bootstrap).getLatestName()\n  .then(([name, latestNamePromise]) => {\n    console.log('name returned');\n    setNameSync(name);\n    updateLatestName(latestNamePromise);\n  });\n\n  function updateLatestName (latestNamePromise) {\n    latestNamePromise.then(([ latestName, nextNamePromise ]) => {\n      setNameSync(latestName);\n      updateLatestName(nextNamePromise);\n    });\n  }\n\n\n  return <div>\n    <p>{name}</p>\n    <input type=\"text\" placeholder={name}\n      onChange={(event) => {\n        setDraftName(event.target.value);\n      }}\n    >\n    </input>\n    <button onClick={() => {\n      E(bootstrap).setName(draftName)\n      .then((ret) => {\n        console.log('name updated successfully!');\n      })\n      .catch((reason) => {\n        console.error(`name update failed: ${reason}`);\n      });\n    }}>Change</button>\n  </div>;\n\n}\n","import './lockdown';\nimport makeCapTpFromStream from 'captp-stream';\nimport './App.css';\nimport { useState } from 'react';\nimport NameComponent from './NameComponent';\n\nconst makeDuplexPair = require('./duplex-socket');\nconst pumpify = require('pumpify');\n\n// Assume two duplex streams connected to each other:\nconst { clientSide, serverSide } = makeDuplexPair();\n\n// Server\n// A bootstrap should be an object with only functions on it.\nlet name = 'Anon';\nlet nextNameUpdate;\nlet nextNamePromise;\nconst serverApi = harden({\n  getName: async () => {\n    console.log('name requested');\n    return new Promise((res) => {\n      setTimeout(() => res(name), 500);\n    });\n  },\n\n  // getLatestName is a promise queue\n  // Each result returns a promise for the next-updated result.\n  // Concept borrowed from GTOR: https://github.com/kriskowal/gtor/\n  getLatestName: async () => {\n    if (!nextNameUpdate) {\n      nextNamePromise = new Promise((res) => {\n        nextNameUpdate = res;\n      });\n    }\n    return [name, nextNamePromise];\n  },\n\n  setName: async (newName) => {\n    name = newName;\n\n    if (nextNameUpdate) {\n      const updateFunc = nextNameUpdate;\n\n      nextNamePromise = new Promise((res) => {\n        nextNameUpdate = res;\n      });\n\n      updateFunc([ newName, nextNamePromise ]);\n    }\n  },\n});\n\nconst { captpStream: serverStream }= makeCapTpFromStream('server', serverApi);\npumpify(serverStream, serverSide, serverStream);\n\n// Client\nconst { getBootstrap, E, captpStream: clientStream } = makeCapTpFromStream('client', harden({}));\npumpify(clientStream, clientSide, clientStream);\n\nfunction App() {\n\n  const [bootstrap, setBootstrap] = useState(undefined);\n  const [error, setError] = useState(undefined);\n  getBootstrap()\n  .then((bootstrap) => {\n    setBootstrap(bootstrap);\n  })\n  .catch((reason) => {\n    setError(reason);\n  });\n\n  let body = error || bootstrap ? <NameComponent bootstrap={bootstrap} E={E}/> : 'Loading'\n  return (\n    <div className=\"App\">\n      <h1>CapTP React Test</h1>\n      { body }\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n// reportWebVitals();\n","// From: https://stackoverflow.com/a/55136548/272576\n// Modified to our eslint and to support object-mode.\nconst Duplex = require('stream').Duplex\nconst assert = require('assert')\n\n// Define some unique property names.\n// The actual value doesn't matter,\n// so long as they're not used by Node.js for anything else.\nconst kCallback = Symbol('Callback')\nconst kOtherSide = Symbol('Other')\n\n// Define a function `DuplexSocket` whose prototype inherits from `Duplex`\nclass DuplexSocket extends Duplex {\n  constructor (opts) {\n    // Let Node.js initialize everything it needs to\n    super(opts)\n    // Define two values we will be using\n    // kCallback saves a temporary reference to a function while\n    this[kCallback] = null\n    // kOtherSide will be the reference to the other side of the stream\n    this[kOtherSide] = null\n  }\n\n  _read () {\n    // This is called when this side receives a push() call\n    // If the other side set a callback for us to call,\n    // then first clear that reference\n    // (it might be immediately set to a new value again),\n    // then call the function.\n    const callback = this[kCallback]\n    if (callback) {\n      this[kCallback] = null\n      callback()\n    }\n  }\n\n  _write (chunk, _encoding, callback) {\n    // This is called when someone writes to the stream\n    // Ensure there's a reference to the other side before trying to call it\n    assert.notStrictEqual(this[kOtherSide], null)\n    // Ensure that the other-side callback is empty before setting it\n    // If push immediately calls _read, this should never be a problem\n    assert.strictEqual(this[kOtherSide][kCallback], null)\n    // Let Node.js know when _read has been called\n    this[kOtherSide][kCallback] = callback\n    // And finally, send the other side the data to be read\n    this[kOtherSide].push(chunk)\n  }\n\n  _final (callback) {\n    // Ask the other side to let us know it received our EOF request\n    this[kOtherSide].on('end', callback)\n    // And finally, pushing null signals the end of the stream\n    this[kOtherSide].push(null)\n  }\n}\n\nfunction makeDuplexPair () {\n  // Create two pairs of\n  const clientSide = new DuplexSocket({ objectMode: true })\n  const serverSide = new DuplexSocket({ objectMode: true })\n  // Set the other-side reference\n  clientSide[kOtherSide] = serverSide\n  serverSide[kOtherSide] = clientSide\n  // Both instances behave the same, so choice of name doesn't matter,\n  // So long as they're distinguishable.\n  return { clientSide, serverSide }\n}\n\nmodule.exports = makeDuplexPair"],"sourceRoot":""}